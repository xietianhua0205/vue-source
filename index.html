<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<div id="app" title="test" style="color: red;font-size: 20px">{{msg}}</div>
<!--<script src="src/compile/test.js"></script>-->
<script src="dist/vue.js"></script>
<script>
    // umd Vue
    // console.log(Vue)
    // 响应式, vue2， mvvm
    // Vue.mixin({})
    Vue.Mixin({  // 全局的方法
        created() {
            console.log(this.name)
            console.log('a----1')
        }
    })
    Vue.Mixin({  // 全局的方法
        created() {
            console.log(this)
            console.log('b-----2')
        }
    })

    let vm = new Vue({
        el: '#app',
        // data: {},
        data() {
            return {
                msg: 'hello world',
                name: '谢天华',
                list: [1, 2, 3, 4],
                arr: [{
                    a: '1'
                }],
                doc: '测试啊'
            }
        },
        props: {},
        watch: {},
        methods: {},
        created() {
            console.log(this.name)
        }
    })
    setTimeout(() => {
        vm.msg = '张三'
        vm._update(vm._render()) // vm._render() // 获取到vm上实例数据  vm._update 更新页面
    }, 2000)
    // 问题  自动跟新
    // 1.数据变化，自动更新视图
    // 2. vue中更新组组件策略是: 以组件为单位，给每一个组件 添加 一个 watcher,属性变化 调用 watcher

    // vue 初次渲染流程 =》1 初始化数据 =》 2.模板编译 =》 变成 render()=> 生成虚拟节点=》 变成真实Dom=》放到页面

    // vue 模板编译  template render  el 注意: el(必须要有), 先走 render（） 再走 template， 生命周期图

    // vue 生命周期  实现原理  源码实现总结
    // (1) Vue.minix({}) // 混入  (2) 设计模式 订阅发布模式  vue  options:{data:[],watch:[]}
</script>
</body>
</html>
